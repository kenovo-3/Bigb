<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Simple Temple-Run Style — The Last Run Lite</title>
<style>
  :root{--bg:#050610;--panel:rgba(0,0,0,0.6);--accent:#16a34a;--danger:#ef4444}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071020 0%, #0b1220 60%, #07121a 100%);font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
  #game { width:100vw; height:100vh; position:relative; overflow:hidden; touch-action:none; }
  canvas { display:block; width:100%; height:100%; }
  .ui { position:absolute; left:16px; top:16px; color:white; z-index:40; max-width:34ch; }
  .title { font-weight:700; font-size:20px; margin:0 0 6px 0; letter-spacing:0.4px }
  .subtitle { font-size:13px; color:rgba(255,255,255,0.85); margin:0 0 12px 0 }
  .panel { background:var(--panel); padding:12px; border-radius:10px; box-shadow:0 6px 20px rgba(0,0,0,0.6) }
  .menu { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:50 }
  .menu-inner { width:min(520px,94vw); padding:22px; border-radius:12px; background:linear-gradient(180deg,rgba(10,10,14,0.75),rgba(0,0,0,0.6)); text-align:center; color:white }
  .big { font-size:28px; font-weight:700; margin-bottom:8px }
  .btn { background:var(--accent); border:none; color:white; padding:10px 16px; border-radius:8px; font-weight:600; cursor:pointer }
  .btn.secondary { background:#374151 }
  .hud { position:absolute; right:16px; top:16px; z-index:40; color:white }
  .hud .score { font-family:monospace; font-weight:700; font-size:20px }
  .footer { position:absolute; left:16px; bottom:16px; color:rgba(255,255,255,0.7); font-size:12px }
  /* Mobile controls */
  .controls { position:absolute; bottom:18px; left:50%; transform:translateX(-50%); display:flex; gap:12px; z-index:60; }
  .ctrl-btn { width:64px; height:64px; border-radius:12px; background:rgba(0,0,0,0.45); display:flex; align-items:center; justify-content:center; color:white; font-weight:700; font-size:20px; user-select:none; touch-action:none }
  .ctrl-btn:active { transform:translateY(2px) }
  .small { width:48px; height:48px; border-radius:10px; font-size:18px }
  .game-over { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:60; }
  .go-inner { background:rgba(0,0,0,0.8); padding:20px; border-radius:12px; text-align:center; color:white }
  @media(min-width:768px){ .big{font-size:36px} .ctrl-btn{display:none} }
</style>
</head>
<body>
<div id="game">
  <!-- Three.js canvas will be injected here -->
  <div id="menu" class="menu">
    <div class="menu-inner">
      <div class="big">The Last Run — Lite</div>
      <div style="margin-bottom:12px;color:rgba(255,255,255,0.9)">A smooth, simple Temple-Run-like prototype. Dodge obstacles. Survive as far as you can.</div>
      <div style="display:flex;gap:10px;justify-content:center;margin-bottom:12px">
        <button id="playBtn" class="btn">Play</button>
        <button id="howBtn" class="btn secondary">How to</button>
      </div>
      <div style="font-size:13px;color:rgba(255,255,255,0.75)">Controls: A/D or ←/→ to move, Space to jump. On mobile use on-screen buttons.</div>
    </div>
  </div>

  <div id="hud" class="hud panel">
    <div style="font-size:12px;color:rgba(255,255,255,0.85)">Distance</div>
    <div class="score" id="score">0</div>
  </div>

  <div class="footer">Prototype • Smooth Graphics • Lanes: 3</div>

  <div id="controls" class="controls" aria-hidden="false">
    <div id="leftBtn" class="ctrl-btn">◀</div>
    <div id="jumpBtn" class="ctrl-btn">⤴</div>
    <div id="rightBtn" class="ctrl-btn">▶</div>
  </div>

  <div id="gameOver" class="game-over" style="display:none">
    <div class="go-inner">
      <div style="font-size:22px;font-weight:700">Game Over</div>
      <div id="finalScore" style="margin-top:8px;font-family:monospace"></div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:center">
        <button id="retryBtn" class="btn">Retry</button>
        <button id="menuBtn" class="btn secondary">Menu</button>
      </div>
    </div>
  </div>
</div>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
(() => {
  // Basic scene, camera, renderer
  let scene, camera, renderer, clock;
  let player, playerState;
  const chunks = [];
  const obstacles = [];
  const LANE_X = [-2.4, 0, 2.4]; // lane x positions
  const CHUNK_LENGTH = 12;
  const VISIBLE_CHUNKS = 10;

  // Game state
  let running = false;
  let paused = false;
  let score = 0;
  let speed = 0.18; // base speed
  let lastSpawn = 0;

  // Responsive mount
  const mount = document.getElementById('game');
  const hudScore = document.getElementById('score');
  const menu = document.getElementById('menu');
  const gameOverEl = document.getElementById('gameOver');
  const finalScoreEl = document.getElementById('finalScore');

  // Touch/buttons
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const jumpBtn = document.getElementById('jumpBtn');
  const playBtn = document.getElementById('playBtn');
  const retryBtn = document.getElementById('retryBtn');
  const menuBtn = document.getElementById('menuBtn');
  const howBtn = document.getElementById('howBtn');

  // Init Three
  function initThree() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x05101a, 0.025);
    camera = new THREE.PerspectiveCamera(60, mount.clientWidth / mount.clientHeight, 0.1, 1000);
    camera.position.set(0, 4.3, 9);
    camera.lookAt(0,1,0);

    renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(mount.clientWidth, mount.clientHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    mount.insertBefore(renderer.domElement, mount.firstChild);

    // Lights
    const hemi = new THREE.HemisphereLight(0xbfeaff, 0x1a1a1a, 0.6);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5,12,5);
    dir.castShadow = true;
    dir.shadow.mapSize.set(1024,1024);
    dir.shadow.camera.near = 0.5;
    dir.shadow.camera.far = 50;
    scene.add(dir);

    // Ground ambient subtle tile
    const groundMat = new THREE.MeshStandardMaterial({ color:0x101822, roughness:1 });
    // create chunk geometry when building chunks
    clock = new THREE.Clock();
  }

  // Player
  function createPlayer() {
    const geo = new THREE.BoxGeometry(1,1.6,1);
    const mat = new THREE.MeshStandardMaterial({ color:0x00d07a, metalness:0.1, roughness:0.6 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = true;
    mesh.position.set(0,1,0);
    scene.add(mesh);
    // state
    playerState = { lane:1, x:0, z:0, vy:0, grounded:true, height:1.6, sliding:false };
    player = mesh;
  }

  // Create a chunk (floor + walls)
  function makeChunk() {
    const group = new THREE.Group();
    // floor
    const floorGeo = new THREE.BoxGeometry(8.5, 0.5, CHUNK_LENGTH);
    const floorMat = new THREE.MeshStandardMaterial({ color:0x0d1a26 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.receiveShadow = true;
    floor.position.y = 0;
    group.add(floor);

    // side rails
    const sideGeo = new THREE.BoxGeometry(0.6, 2.2, CHUNK_LENGTH);
    const sideMat = new THREE.MeshStandardMaterial({ color:0x071018 });
    const left = new THREE.Mesh(sideGeo, sideMat);
    left.position.set(-4.2,1.1,0);
    left.receiveShadow = true;
    group.add(left);
    const right = left.clone();
    right.position.set(4.2,1.1,0);
    group.add(right);

    group.userData.obstacles = [];
    return group;
  }

  // Spawn initial chunks
  function spawnInitialChunks() {
    // clear any existing
    for (const c of chunks) { scene.remove(c); }
    chunks.length = 0;
    for (let i = 0; i < VISIBLE_CHUNKS; i++) {
      const c = makeChunk();
      c.position.z = -i * CHUNK_LENGTH;
      scene.add(c);
      chunks.push(c);
    }
  }

  // Spawn obstacle on chunk
  function addObstacleToChunk(chunk) {
    // small chance of gap vs block vs spinner
    const type = Math.random();
    if (type < 0.12) {
      // gap: visual darker patch, but we actually reduce floor collision by creating a box sunk
      const hole = new THREE.Mesh(new THREE.BoxGeometry(5,0.1,4), new THREE.MeshStandardMaterial({ color:0x000814 }));
      hole.position.set((Math.random()-0.5)*3, -0.24, (Math.random()-0.5)*(CHUNK_LENGTH-2));
      chunk.add(hole);
      chunk.userData.obstacles.push({ mesh:hole, kind:'gap' });
    } else if (type < 0.78) {
      // block
      const w = 0.8 + Math.random()*1.2;
      const h = 0.8 + Math.random()*1.6;
      const block = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.8), new THREE.MeshStandardMaterial({ color:0xff4d4d }));
      block.position.set(LANE_X[Math.floor(Math.random()*3)], h/2, (Math.random()-0.5)*(CHUNK_LENGTH-2));
      block.castShadow = true;
      chunk.add(block);
      chunk.userData.obstacles.push({ mesh:block, kind:'block' });
    } else {
      // spike orb (floating)
      const orb = new THREE.Mesh(new THREE.SphereGeometry(0.28,12,12), new THREE.MeshStandardMaterial({ emissive:0xffaa33, emissiveIntensity:0.8 }));
      orb.position.set(LANE_X[Math.floor(Math.random()*3)], 1.1, (Math.random()-0.5)*(CHUNK_LENGTH-2));
      chunk.add(orb);
      chunk.userData.obstacles.push({ mesh:orb, kind:'orb' });
    }
  }

  // Recycle chunks that passed the player
  function recycleChunks() {
    for (const c of chunks) {
      if (c.position.z > CHUNK_LENGTH + 4) {
        // move to front
        const backMost = chunks.reduce((p,n)=> n.position.z < p.position.z ? n : p, chunks[0]);
        c.position.z = backMost.position.z - CHUNK_LENGTH;
        // remove previous obstacles
        for (const o of c.userData.obstacles) { try { c.remove(o.mesh||o); } catch(e){} }
        c.userData.obstacles.length = 0;
        // randomly add 0..2 obstacles
        if (Math.random() > 0.35) addObstacleToChunk(c);
      }
    }
  }

  // Collision detection using bounding boxes
  function checkCollisions() {
    if (!player) return false;
    const playerBox = new THREE.Box3().setFromObject(player);
    // enlarge slightly
    playerBox.expandByScalar(0.06);
    for (const c of chunks) {
      for (const o of c.userData.obstacles) {
        const mesh = o.mesh || o;
        const box = new THREE.Box3().setFromObject(mesh);
        if (o.kind === 'gap') {
          // check if player's feet are above a hole (i.e., player over hole and low height)
          const holeCenter = mesh.getWorldPosition(new THREE.Vector3());
          const dz = Math.abs(holeCenter.z - player.position.z);
          const dx = Math.abs(holeCenter.x - player.position.x);
          if (dz < 1.6 && dx < 2.5 && player.position.y < 1.05) {
            return true; // fell into gap
          }
        } else {
          if (playerBox.intersectsBox(box)) return true;
        }
      }
    }
    return false;
  }

  // Input handling
  const keys = {};
  function onKeyDown(e) {
    keys[e.key] = true;
    if (!running) return;
    if (e.key === 'ArrowLeft' || e.key === 'a') moveLane(-1);
    if (e.key === 'ArrowRight' || e.key === 'd') moveLane(1);
    if (e.key === ' ' || e.code === 'Space') attemptJump();
    if (e.key === 'p') paused = !paused;
  }
  function onKeyUp(e) { keys[e.key] = false; }

  // Touch & button handlers
  let touchStartX = null;
  function onTouchStart(e) {
    if (!running) return;
    const t = e.changedTouches[0];
    touchStartX = t.clientX;
  }
  function onTouchEnd(e) {
    if (!running || touchStartX === null) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStartX;
    if (Math.abs(dx) > 40) {
      if (dx < 0) moveLane(-1);
      else moveLane(1);
    } else {
      attemptJump();
    }
    touchStartX = null;
  }

  // Buttons
  leftBtn.addEventListener('pointerdown', ()=> moveLane(-1));
  rightBtn.addEventListener('pointerdown', ()=> moveLane(1));
  jumpBtn.addEventListener('pointerdown', ()=> attemptJump());
  playBtn.addEventListener('click', startGame);
  retryBtn.addEventListener('click', restartGame);
  menuBtn.addEventListener('click', showMenu);
  howBtn.addEventListener('click', ()=> alert('Move: A/D or ←/→. Jump: Space or Jump button. Avoid red blocks and gaps.'));

  // Lane switch with smoothing
  function moveLane(dir) {
    if (!playerState || playerState.sliding) return;
    const target = THREE.MathUtils.clamp(playerState.lane + dir, 0, 2);
    playerState.lane = target;
    playerState.targetX = LANE_X[target];
  }

  // Jump
  function attemptJump() {
    if (!playerState || !playerState.grounded || playerState.sliding) return;
    playerState.vy = 0.42;
    playerState.grounded = false;
  }

  // Slide (not implemented heavy, just quick duck)
  function startSlide() {
    if (!playerState || playerState.sliding) return;
    playerState.sliding = true;
    player.scale.y = 0.5;
    setTimeout(()=>{ player.scale.y = 1; playerState.sliding=false; }, 550);
  }

  // Game loop
  function animate() {
    requestAnimationFrame(animate);
    if (!renderer) return;
    const dt = Math.min(0.033, clock.getDelta()); // clamp delta

    if (running && !paused) {
      // speed ramp up slightly with score
      speed += 0.00001 * Math.max(1, score);

      // update player x smoothing
      if (playerState.targetX === undefined) playerState.targetX = LANE_X[playerState.lane];
      player.position.x = THREE.MathUtils.lerp(player.position.x, playerState.targetX, 10 * dt);

      // gravity & jump
      playerState.vy -= 0.025;
      player.position.y += playerState.vy;
      if (player.position.y <= 1) { player.position.y = 1; playerState.vy = 0; playerState.grounded = true; }

      // move chunks forward relative to player (simulate forward motion)
      for (const c of chunks) {
        c.position.z += speed * (1 + score/2000);
      }

      recycleChunks();

      // spawn initial obstacles
      lastSpawn += dt;
      if (lastSpawn > 0.9) { // spawn occasionally
        const candidate = chunks[Math.floor(Math.random()*chunks.length)];
        if (Math.random() > 0.4) addObstacleToChunk(candidate);
        lastSpawn = 0;
      }

      // score
      score += speed*12*dt;
      hudScore.textContent = Math.floor(score);

      // simple collision
      if (checkCollisions()) {
        // Game over
        running = false;
        gameOver();
      }

      // camera follow smoothing slightly behind player
      const camTarget = new THREE.Vector3(player.position.x, player.position.y + 3.5, player.position.z + 9);
      camera.position.lerp(camTarget, 2*dt);
      camera.lookAt(player.position.x, player.position.y + 0.8, player.position.z - 2);
    }

    renderer.render(scene, camera);
  }

  // Start game
  function startGame() {
    // If first time, init everything
    if (!scene) {
      initThree();
      createPlayer();
      spawnInitialChunks();
      // events
      window.addEventListener('keydown', onKeyDown);
      window.addEventListener('keyup', onKeyUp);
      mount.addEventListener('touchstart', onTouchStart, {passive:true});
      mount.addEventListener('touchend', onTouchEnd, {passive:true});
      clock = new THREE.Clock();
      animate();
    } else {
      // reset state but keep scene
      // remove previous obstacles
      for (const c of chunks) {
        for (const o of c.userData.obstacles) { try { c.remove(o.mesh||o); } catch(e){} }
        c.userData.obstacles.length = 0;
      }
      player.position.set(0,1,0);
      playerState = { lane:1, x:0, z:0, vy:0, grounded:true, height:1.6, sliding:false };
      for (let i=0;i<chunks.length;i++) chunks[i].position.z = -i * CHUNK_LENGTH;
    }

    score = 0; hudScore.textContent = '0';
    speed = 0.18;
    lastSpawn = 0;
    running = true; paused = false;
    menu.style.display = 'none';
    gameOverEl.style.display = 'none';
  }

  function restartGame() {
    // quick full reload to ensure clean state
    // but we'll instead just call startGame to reset
    startGame();
  }

  function showMenu() {
    running = false;
    paused = false;
    menu.style.display = 'flex';
    gameOverEl.style.display = 'none';
  }

  function gameOver() {
    gameOverEl.style.display = 'flex';
    finalScoreEl.textContent = 'Distance: ' + Math.floor(score);
    // show cursor/menu
    // keep renderer running so scene visible
  }

  // Responsive resize
  function resize() {
    if (!renderer || !camera) return;
    const w = mount.clientWidth;
    const h = mount.clientHeight;
    renderer.setSize(w,h);
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', resize);

  // start with menu visible (do nothing)
  // Provide keyboard hint to start
  // Expose some debug shortcuts
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !running) startGame();
    if (e.key === 'r' && !running) restartGame();
  });

  // initialize quickly (so user sees background) - but delay heavy inits until Play
  // Pre-warm a scene: create minimal renderer so background appears immediately
  (function prewarm() {
    // create small renderer to fill background quickly without heavy geometry
    if (!renderer) {
      initThree();
      // add a subtle background structure so it doesn't look empty
      const ringGeo = new THREE.TorusGeometry(18, 1.2, 16, 100);
      const ringMat = new THREE.MeshStandardMaterial({ color:0x061730, roughness:0.9 });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = Math.PI/2;
      ring.position.z = -40;
      scene.add(ring);

      // small ambient floor plane so fog blends
      const plane = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({ color:0x050a10 }));
      plane.rotation.x = -Math.PI/2;
      plane.position.y = -0.25;
      scene.add(plane);
      renderer.render(scene, camera);
    }
  })();

})();
</script>
</body>
</html>
