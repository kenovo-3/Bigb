<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Last Run — Panda Run (Lite)</title>
<style>
  :root{
    --bg1:#071124;
    --bg2:#08121a;
    --panel:rgba(0,0,0,0.55);
    --accent:#16a34a;
    --danger:#ef4444;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1) 0%, var(--bg2) 60%);font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#fff}
  #game { width:100vw; height:100vh; position:relative; overflow:hidden; touch-action:none; }
  canvas{ display:block; width:100%; height:100%; }
  .menu { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:50 }
  .menu-inner{ width:min(720px,94vw); padding:20px; border-radius:12px; background:linear-gradient(180deg, rgba(6,8,12,0.85), rgba(0,0,0,0.6)); text-align:center; box-shadow:0 8px 30px rgba(0,0,0,0.6); }
  .title{ font-size:28px; font-weight:800; margin:0 0 8px 0 }
  .subtitle{ font-size:14px; color:rgba(255,255,255,0.85); margin:0 0 14px 0 }
  .btn{ background:var(--accent); color:white; border:0; padding:10px 14px; border-radius:10px; font-weight:700; cursor:pointer; box-shadow:0 6px 18px rgba(0,0,0,0.4)}
  .btn.secondary{ background:#374151 }
  .hud{ position:absolute; left:14px; top:14px; z-index:60; display:flex; gap:12px; align-items:center }
  .panel{ background:var(--panel); padding:10px 12px; border-radius:10px; font-weight:700; font-family:monospace}
  .hud .small{ font-family:Inter,Arial; font-weight:600; color:#ddd; font-size:13px }
  .footer{ position:absolute; left:14px; bottom:14px; color:rgba(255,255,255,0.7); font-size:12px; z-index:60 }
  .controls{ position:absolute; bottom:16px; left:50%; transform:translateX(-50%); display:flex; gap:12px; z-index:70 }
  .ctrl{ width:68px; height:68px; border-radius:12px; background:rgba(0,0,0,0.45); display:flex; align-items:center; justify-content:center; color:white; font-weight:800; font-size:22px; user-select:none; touch-action:manipulation; }
  .ctrl.small{ width:54px; height:54px; font-size:18px }
  .game-over{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:80; }
  .go-inner{ background:rgba(0,0,0,0.82); padding:18px; border-radius:12px; text-align:center; color:white; width:min(520px,86vw) }
  @media(min-width:900px){ .title{ font-size:40px } .ctrl{ display:none } }
</style>
</head>
<body>
<div id="game">
  <div id="menu" class="menu">
    <div class="menu-inner">
      <div class="title">The Last Run — Panda Run</div>
      <div class="subtitle">Cartoon panda runner, polished materials, synthesized sounds — no downloads required.</div>
      <div style="display:flex;gap:10px;justify-content:center;margin-bottom:12px">
        <button id="playBtn" class="btn">Play</button>
        <button id="howBtn" class="btn secondary">How to</button>
      </div>
      <div style="font-size:13px;color:rgba(255,255,255,0.85)">Controls: A/D or ←/→ to move lanes, Space to jump. On mobile use the on-screen buttons (left/jump/right).</div>
    </div>
  </div>

  <div class="hud">
    <div class="panel">Distance: <span id="score">0</span></div>
    <div class="panel">Coins: <span id="coins">0</span></div>
  </div>

  <div class="footer">Prototype • Panda Model • Synth SFX • Responsive</div>

  <div id="controls" class="controls" aria-hidden="false">
    <div id="leftBtn" class="ctrl">◀</div>
    <div id="jumpBtn" class="ctrl small">⤴</div>
    <div id="rightBtn" class="ctrl">▶</div>
  </div>

  <div id="gameOver" class="game-over" style="display:none">
    <div class="go-inner">
      <div style="font-size:22px;font-weight:800">Game Over</div>
      <div id="final" style="margin-top:8px;font-family:monospace"></div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:center">
        <button id="retryBtn" class="btn">Retry</button>
        <button id="menuBtn" class="btn secondary">Menu</button>
      </div>
    </div>
  </div>
</div>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
(() => {
  // Basic config
  const LANE_X = [-2.4, 0, 2.4];
  const CHUNK_LENGTH = 12;
  const VISIBLE = 10;
  const mount = document.getElementById('game');
  const scoreEl = document.getElementById('score');
  const coinsEl = document.getElementById('coins');
  const menu = document.getElementById('menu');
  const playBtn = document.getElementById('playBtn');
  const howBtn = document.getElementById('howBtn');
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const jumpBtn = document.getElementById('jumpBtn');
  const gameOverEl = document.getElementById('gameOver');
  const finalEl = document.getElementById('final');
  const retryBtn = document.getElementById('retryBtn');
  const menuBtn = document.getElementById('menuBtn');

  let scene, camera, renderer, clock;
  let player, panda, pandaParts = [];
  let chunks = [];
  let running = false;
  let paused = false;
  let score = 0;
  let coins = 0;
  let speed = 0.18;
  let lastSpawn = 0;
  let audioCtx, masterGain, bgGain;
  let jumpSound, collectSound, hitSound;

  function rnd(min,max){ return Math.random()*(max-min)+min; }

  function initScene() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x071124, 0.02);

    const w = mount.clientWidth;
    const h = mount.clientHeight;
    camera = new THREE.PerspectiveCamera(60, w/h, 0.1, 1000);
    camera.position.set(0,4.3,9);
    camera.lookAt(0,1,0);

    renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setSize(w,h);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    mount.insertBefore(renderer.domElement, mount.firstChild);

    const hemi = new THREE.HemisphereLight(0xbfeaff, 0x0b0b12, 0.6);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5,12,5);
    dir.castShadow = true;
    dir.shadow.mapSize.set(1024,1024);
    dir.shadow.camera.near = 0.5;
    dir.shadow.camera.far = 50;
    scene.add(dir);

    const ringGeo = new THREE.TorusGeometry(28, 2.2, 16, 120);
    const ringMat = new THREE.MeshStandardMaterial({ color:0x071426, roughness:1.0, metalness:0.0 });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = Math.PI/2;
    ring.position.z = -110;
    scene.add(ring);

    const plane = new THREE.Mesh(new THREE.PlaneGeometry(400,400), new THREE.MeshStandardMaterial({ color:0x050a10 }));
    plane.rotation.x = -Math.PI/2;
    plane.position.y = -0.25;
    scene.add(plane);

    clock = new THREE.Clock();
  }

  function createPanda() {
    panda = new THREE.Group();

    const whiteMat = new THREE.MeshStandardMaterial({ color:0xf7f7f7, metalness:0.03, roughness:0.7 });
    const blackMat = new THREE.MeshStandardMaterial({ color:0x0b0b0b, metalness:0.02, roughness:0.6 });
    const pinkMat = new THREE.MeshStandardMaterial({ color:0xffc0c0, metalness:0.02, roughness:0.6 });

    const body = new THREE.Mesh(new THREE.SphereGeometry(0.9,24,24), whiteMat);
    body.scale.set(1,1.05,1.15);
    body.position.set(0,0.55,0);
    body.castShadow = true;
    panda.add(body);
    pandaParts.push(body);

    const belly = new THREE.Mesh(new THREE.SphereGeometry(0.6,18,18), new THREE.MeshStandardMaterial({ color:0xefeef0, roughness:0.8 }));
    belly.scale.set(0.9,0.8,1);
    belly.position.set(0,0.35,0.6);
    belly.rotation.x = -0.4;
    belly.receiveShadow = true;
    body.add(belly);

    const head = new THREE.Mesh(new THREE.SphereGeometry(0.6,24,24), whiteMat);
    head.position.set(0,1.3,0.05);
    head.castShadow = true;
    panda.add(head);
    pandaParts.push(head);

    const earGeo = new THREE.SphereGeometry(0.22,16,16);
    const leftEar = new THREE.Mesh(earGeo, blackMat); leftEar.position.set(-0.36,1.6,-0.05); panda.add(leftEar);
    const rightEar = leftEar.clone(); rightEar.position.x = 0.36; panda.add(rightEar);

    const patchGeo = new THREE.SphereGeometry(0.22,16,16);
    const leftPatch = new THREE.Mesh(patchGeo, blackMat); leftPatch.position.set(-0.22,1.26,0.48); leftPatch.rotation.set(-0.2,0.1,0.1); leftPatch.scale.set(1.2,0.9,0.6); panda.add(leftPatch);
    const rightPatch = leftPatch.clone(); rightPatch.position.x = 0.22; panda.add(rightPatch);

    const eyeGeo = new THREE.SphereGeometry(0.06,10,10);
    const leftEye = new THREE.Mesh(eyeGeo, new THREE.MeshStandardMaterial({ color:0xffffff })); leftEye.position.set(-0.22,1.28,0.64); panda.add(leftEye);
    const rightEye = leftEye.clone(); rightEye.position.x = 0.22; panda.add(rightEye);

    const nose = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.06,0.08), blackMat); nose.position.set(0,1.15,0.72); panda.add(nose);

    const armGeo = new THREE.CapsuleGeometry(0.12,0.5,4,8);
    const leftArm = new THREE.Mesh(armGeo, blackMat); leftArm.position.set(-0.7,0.9,0.1); leftArm.rotation.z = 0.45; panda.add(leftArm);
    const rightArm = leftArm.clone(); rightArm.position.x = 0.7; rightArm.rotation.z = -0.45; panda.add(rightArm);

    const legGeo = new THREE.CapsuleGeometry(0.16,0.36,4,8);
    const leftLeg = new THREE.Mesh(legGeo, blackMat); leftLeg.position.set(-0.28,0.0,0.2); panda.add(leftLeg);
    const rightLeg = leftLeg.clone(); rightLeg.position.x = 0.28; panda.add(rightLeg);

    panda.scale.set(0.95,0.95,0.95);
    panda.position.set(0,1,0);
    panda.castShadow = true;
    scene.add(panda);
    player = panda;
  }

  function makeChunk() {
    const group = new THREE.Group();
    const floorGeo = new THREE.BoxGeometry(8.5, 0.5, CHUNK_LENGTH);
    const floorMat = new THREE.MeshStandardMaterial({ color:0x0d1a26, roughness:0.9 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.receiveShadow = true;
    floor.position.y = 0;
    group.add(floor);

    const sideGeo = new THREE.BoxGeometry(0.6,2.2, CHUNK_LENGTH);
    const sideMat = new THREE.MeshStandardMaterial({ color:0x071018 });
    const left = new THREE.Mesh(sideGeo, sideMat); left.position.set(-4.2,1.1,0); left.receiveShadow=true; group.add(left);
    const right = left.clone(); right.position.x = 4.2; group.add(right);

    group.userData.obstacles = [];
    return group;
  }

  function spawnInitial() {
    for (const c of chunks) { try{ scene.remove(c) }catch(e){} }
    chunks = [];
    for (let i=0;i<VISIBLE;i++){
      const c = makeChunk();
      c.position.z = -i*CHUNK_LENGTH;
      scene.add(c);
      chunks.push(c);
      if (Math.random()>0.55) addObstacle(c);
    }
  }

  function addObstacle(chunk) {
    const r = Math.random();
    if (r < 0.12) {
      const hole = new THREE.Mesh(new THREE.BoxGeometry(5,0.05,4), new THREE.MeshStandardMaterial({ color:0x000914 }));
      hole.position.set((Math.random()-0.5)*2.5, -0.245, (Math.random()-0.5)*(CHUNK_LENGTH-2));
      chunk.add(hole);
      chunk.userData.obstacles.push({ mesh:hole, type:'gap' });
      return;
    }
    if (r < 0.7) {
      const w = 0.8 + Math.random()*1.2;
      const h = 0.8 + Math.random()*1.6;
      const block = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.8), new THREE.MeshStandardMaterial({ color:0xff4d4d }));
      block.position.set(LANE_X[Math.floor(Math.random()*3)], h/2, (Math.random()-0.5)*(CHUNK_LENGTH-2));
      block.castShadow = true;
      chunk.add(block);
      chunk.userData.obstacles.push({ mesh:block, type:'block' });
      return;
    }
    const coin = new THREE.Mesh(new THREE.SphereGeometry(0.18,10,10), new THREE.MeshStandardMaterial({ color:0xffd166, emissive:0xffd166, emissiveIntensity:0.6 }));
    coin.position.set(LANE_X[Math.floor(Math.random()*3)], 1.1, (Math.random()-0.5)*(CHUNK_LENGTH-2));
    chunk.add(coin);
    chunk.userData.obstacles.push({ mesh:coin, type:'coin' });
  }

  function recycle() {
    for (const c of chunks) {
      if (c.position.z > CHUNK_LENGTH + 4) {
        const back = chunks.reduce((p,n)=> n.position.z < p.position.z ? n : p, chunks[0]);
        c.position.z = back.position.z - CHUNK_LENGTH;
        for (const o of c.userData.obstacles) {
          try{ c.remove(o.mesh||o) }catch(e){}
        }
        c.userData.obstacles.length = 0;
        if (Math.random() > 0.35) addObstacle(c);
        if (Math.random() > 0.88) addObstacle(c);
      }
    }
  }

  function checkCollision() {
    if (!player) return false;
    const pBox = new THREE.Box3().setFromObject(player);
    pBox.expandByScalar(0.04);
    for (const c of chunks) {
      for (const obj of c.userData.obstacles) {
        const m = obj.mesh;
        const t = obj.type;
        if (t === 'coin') {
          const worldPos = new THREE.Vector3();
          m.getWorldPosition(worldPos);
          const d = worldPos.distanceTo(player.position);
          if (d < 0.8) {
            try{ c.remove(m); }catch(e){}
            obj.collected = true;
            playCollect();
            coins++; coinsEl.textContent = coins;
            continue;
          }
        } else if (t === 'gap') {
          const worldPos = new THREE.Vector3(); m.getWorldPosition(worldPos);
          const dz = Math.abs(worldPos.z - player.position.z);
          const dx = Math.abs(worldPos.x - player.position.x);
          if (dz < 1.6 && dx < 2.2 && player.position.y < 1.05) return true;
        } else {
          const box = new THREE.Box3().setFromObject(m);
          if (pBox.intersectsBox(box)) return true;
        }
      }
    }
    return false;
  }

  function initAudio() {
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    } catch(e){}
    if (!audioCtx) return;
    masterGain = audioCtx.createGain(); masterGain.gain.value = 0.9; masterGain.connect(audioCtx.destination);
    bgGain = audioCtx.createGain(); bgGain.gain.value = 0.03; bgGain.connect(masterGain);

    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = 220;
    const lfo = audioCtx.createOscillator();
    lfo.type = 'sine';
    lfo.frequency.value = 0.25;
    const lfoGain = audioCtx.createGain(); lfoGain.gain.value = 20;
    lfo.connect(lfoGain);
    lfoGain.connect(osc.frequency);
    const bgGainNode = audioCtx.createGain(); bgGainNode.gain.value = 0.0018;
    osc.connect(bgGainNode); bgGainNode.connect(bgGain);
    osc.start(); lfo.start();

    jumpSound = (when=0) => {
      if (!audioCtx) return;
      const t = audioCtx.currentTime + when;
      const o = audioCtx.createOscillator(); o.type = 'sine';
      o.frequency.setValueAtTime(220, t);
      o.frequency.exponentialRampToValueAtTime(420, t+0.12);
      const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0015,t); g.gain.exponentialRampToValueAtTime(0.0005,t+0.12); g.gain.exponentialRampToValueAtTime(0.00001,t+0.5);
      o.connect(g); g.connect(masterGain);
      o.start(t); o.stop(t+0.5);
    };

    collectSound = (when=0) => {
      if (!audioCtx) return;
      const t = audioCtx.currentTime + when;
      const o1 = audioCtx.createOscillator(); o1.type='triangle'; o1.frequency.setValueAtTime(880,t);
      const o2 = audioCtx.createOscillator(); o2.type='sine'; o2.frequency.setValueAtTime(1320,t);
      const g = audioCtx.createGain(); g.gain.setValueAtTime(0.002,t); g.gain.exponentialRampToValueAtTime(0.00001,t+0.35);
      o1.connect(g); o2.connect(g); g.connect(masterGain);
      o1.start(t); o2.start(t); o1.stop(t+0.35); o2.stop(t+0.35);
    };

    hitSound = (when=0) => {
      if (!audioCtx) return;
      const t = audioCtx.currentTime + when;
      const o = audioCtx.createOscillator(); o.type = 'sawtooth'; o.frequency.setValueAtTime(140, t);
      const g = audioCtx.createGain(); g.gain.setValueAtTime(0.004, t); g.gain.exponentialRampToValueAtTime(0.00001, t+0.45);
      o.connect(g); g.connect(masterGain);
      o.start(t); o.stop(t+0.45);
    };
  }

  function playJump(){ if (jumpSound) jumpSound(); }
  function playCollect(){ if (collectSound) collectSound(); }
  function playHit(){ if (hitSound) hitSound(); }

  const keys={};
  function onKeyDown(e){
    keys[e.key]=true;
    if (!running) return;
    if (e.key==='ArrowLeft' || e.key==='a') laneLeft();
    if (e.key==='ArrowRight' || e.key==='d') laneRight();
    if (e.key===' ' || e.code==='Space') doJump();
  }
  function onKeyUp(e){ keys[e.key]=false; }

  leftBtn.addEventListener('pointerdown', ()=>{ if (!running) return; laneLeft(); });
  rightBtn.addEventListener('pointerdown', ()=>{ if (!running) return; laneRight(); });
  jumpBtn.addEventListener('pointerdown', ()=>{ if (!running) return; doJump(); });

  function laneLeft(){ if (!player) return; const state = player.userData; state.lane = Math.max(0, state.lane-1); state.targetX = LANE_X[state.lane]; }
  function laneRight(){ if (!player) return; const state = player.userData; state.lane = Math.min(2, state.lane+1); state.targetX = LANE_X[state.lane]; }
  function doJump(){ const state = player && player.userData; if (!state) return; if (!state.grounded) return; state.vy = 0.42; state.grounded=false; playJump(); }

  function createPlayer() {
    createPanda();
    player.userData = { lane:1, targetX:LANE_X[1], vy:0, grounded:true, sliding:false };
  }

  function animate() {
    requestAnimationFrame(animate);
    if (!renderer) return;
    const dt = Math.min(0.033, clock.getDelta());

    if (running && !paused) {
      speed += 0.00001*Math.max(1,score);

      if (player && player.userData) {
        const st = player.userData;
        player.position.x = THREE.MathUtils.lerp(player.position.x, st.targetX, 8*dt);

        const t = performance.now()*0.002;
        player.position.y = 1 + Math.sin(t*6)*0.03;
        player.rotation.y = Math.sin(t*2)*0.02;

        st.vy -= 0.025;
        player.position.y += st.vy;
        if (player.position.y <= 1) { player.position.y = 1; st.vy = 0; st.grounded = true; }
      }

      for (const c of chunks) c.position.z += speed*(1 + score/2500);

      recycle();

      lastSpawn += dt;
      if (lastSpawn > 0.9) {
        const idx = Math.floor(Math.random()*chunks.length);
        addObstacle(chunks[idx]);
        lastSpawn = 0;
      }

      score += speed*12*dt;
      scoreEl.textContent = Math.floor(score);

      for (const c of chunks) {
        c.userData.obstacles = c.userData.obstacles.filter(o => !o.collected);
      }

      if (checkCollision()) {
        playHit();
        running = false;
        gameOver();
      }
    }

    renderer.render(scene, camera);
  }

  function startGame() {
    if (!scene) {
      initScene();
      initAudio();
      createPlayer();
      spawnInitial();
      window.addEventListener('keydown', onKeyDown);
      window.addEventListener('keyup', onKeyUp);
      let touchStartX = null;
      mount.addEventListener('touchstart', (e)=>{ if (!running) return; touchStartX = e.touches[0].clientX; }, {passive:true});
      mount.addEventListener('touchend', (e)=>{
        if (!running || touchStartX === null) return;
        const dx = e.changedTouches[0].clientX - touchStartX;
        if (Math.abs(dx)>40) { if (dx<0) laneLeft(); else laneRight(); }
        touchStartX = null;
      }, {passive:true});
      clock = new THREE.Clock();
      animate();
    } else {
      for (const c of chunks) {
        for (const o of c.userData.obstacles) try{ c.remove(o.mesh||o) }catch(e){}
        c.userData.obstacles.length = 0;
      }
      player.position.set(0,1,0);
      player.userData = { lane:1, targetX:LANE_X[1], vy:0, grounded:true, sliding:false };
      for (let i=0;i<chunks.length;i++) chunks[i].position.z = -i*CHUNK_LENGTH;
    }
    score = 0; coins = 0; speed = 0.18; lastSpawn = 0;
    scoreEl.textContent = '0'; coinsEl.textContent = '0';
    running = true; paused = false;
    menu.style.display = 'none';
    gameOverEl.style.display = 'none';
  }
  function restartGame() { startGame(); }
  function showMenu() {
    running = false; paused = false; menu.style.display = 'flex'; gameOverEl.style.display = 'none';
  }
  function gameOver() {
    gameOverEl.style.display = 'flex';
    finalEl.textContent = 'Distance: ' + Math.floor(score) + '   •   Coins: ' + coins;
    if (bgGain) { bgGain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.5); }
  }

  (function prewarm(){
    initScene();
    const ringGeo = new THREE.TorusGeometry(18, 1.2, 12, 80);
    const ringMat = new THREE.MeshStandardMaterial({ color:0x061730 });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = Math.PI/2;
    ring.position.z = -60;
    scene.add(ring);
    renderer.render(scene, camera);
  })();

  playBtn.addEventListener('click', () => { if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); startGame(); });
  howBtn.addEventListener('click', ()=> alert('Move: A/D or ←/→. Jump: Space or Jump button. Collect coins, avoid obstacles and gaps.'));
  retryBtn.addEventListener('click', ()=> { if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); restartGame(); });
  menuBtn.addEventListener('click', ()=> showMenu());

  function resize() {
    if (!renderer || !camera) return;
    const w = mount.clientWidth;
    const h = mount.clientHeight;
    renderer.setSize(w,h);
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', resize);

  window.addEventListener('keydown', (e)=> {
    if (e.key === 'Enter' && !running) startGame();
    if (e.key === 'm') { if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }
  });

})();
</script>
</body>
</html>
